<html>
<head></head>
<body>
	<table><tr><td id="left" style="vertical-align:top"></td><td id='right' style="vertical-align:top"></td></tr></table>
</body></html>

<script src="gpu.js-develop/bin/gpu-core.js"></script>
<script src="gpu.js-develop/bin/gpu.js"></script>
<script>

// this was just an attempt to see what happens if the functions only run once

// also, I got everything functionalized




var onlylast = true






var left = document.getElementById('left')
var right = document.getElementById('right')

const gpu = new GPU();
left.innerHTML += gpu.getMode()
left.innerHTML += 'left is gpu output. right is true values.'
right.innerHTML += gpu.getMode()
right.innerHTML += 'left is gpu output. right is true values.'

// make variables
var lc = 5
var lv = 2
var li = 10 // 400
var xf = []
for (i =0;i<lc;i++) xf.push(Math.random())
var xv=[]
for (i =0;i<li;i++) {
	var da = []
	for (j =0;j<lv;j++) da.push(Math.random())
	xv.push(da)
}
var yv=xv
var yf=xf
	



const d = gpu.createKernel( function(xv, yv, xf, yf) {
	var civ,i,v,c,d,dx,dy,ci
	civ = this.thread.x
	v = Math.floor((civ) / (lc*li)); // z
	//v = civ / (lc*lv) >> 0
	ci = civ - v * lc * li
	//ci = civ % (lc*li)
	i = Math.floor((ci) / lc)
	//i = Math.floor(civ/lc)%li
	//i = tmp / lc >> 0; // y
	c = ci % lc; // x
	//c=civ%lc
	// d is indexed as civ

	dx = xv[i][v] - xf[c]
	dy = yv[i][v] - yf[c]
	d = Math.sqrt(dx*dx + dy*dy)
	return d
}, {
	dimensions: [lv*lc*li], // y,x
	constants: {lv:lv,lc:lc,li:li}
})


right.innerHTML += "<br>"+"cube"

function dJ(xv,yv,xf,yf,lc,li,lv) {
cube=[]
for (var civ=0; civ<lc*li*lv; civ++) {
	v = Math.floor((civ) / (lc*li)); // z
	//v = civ / (lc*lv) >> 0
	ci = civ - v * lc * li
	//ci = civ % (lc*li)
	i = Math.floor((ci) / lc)
	//i = Math.floor(civ/lc)%li
	//i = tmp / lc >> 0; // y
	c = ci % lc; // x
	//c=civ%lc
	// d is indexed as civ

	dx = xv[i][v] - xf[c]
	dy = yv[i][v] - yf[c]
	d2 = Math.sqrt(dx*dx + dy*dy)
	right.innerHTML += "<br>"+d2
	cube.push(d2)
}
return cube
}
cube =  dJ(xv,yv,xf,yf,lc,li,lv)

const minCube = gpu.createKernel( function(d) {
	var iv,civ,n,d1
	iv = this.thread.x
	
	n=1000
	for (var c = 0; c < lc; c++) {
		civ = c + iv* lc
		// d1 = d[c][i][v] // d at x,y,z
		//(z * xMax * yMax) + (y * xMax) + x;
	
		d1 = d[civ]
		if (d1 < n) {
			n = d1 //min
		}
	}
	return n
}, {
	dimensions: [lv*li*lc], // y,x
	constants: {lv:lv,lc:lc,li:li}
})

right.innerHTML += "<br>"+"min"

function minCubeJ(d,lc,li,lv) {
min=[]
for (var iv=0; iv<li*lv; iv++) {
	n=1000
	for (var c = 0; c < lc; c++) {
		civ = c + iv * lc
		// d1 = d[c][i][v] // d at x,y,z
		//(z * xMax * yMax) + (y * xMax) + x;
	
		d1 = cube[civ]
		if (d1 < n) {
			n = d1 //min
		}
	}
	min.push(n)
	right.innerHTML += "<br>"+n
}
return min
}
min = minCubeJ(cube,lc,li,lv)
// oh, heres a problem... 
// gpu.js doesn't allow integers
// so I can't index by anything other than this.thread.x


const maxCube = gpu.createKernel( function(d) {
	var iv,i,v,dx,dy,civ,n,m,d1
	iv = this.thread.x

	
	m=0
	for (var c = 0; c < lc; c++) {
		civ = c + iv *lc
		// d1 = d[c][i][v] // d at x,y,z
		//(z * xMax * yMax) + (y * xMax) + x;
		d1 = d[civ]
		if (d1 > m) {
			m = d1 //max
		}
	}
	return m
}, {
	dimensions: [lv*li*lc], // y,x
	constants: {lv:lv,lc:lc,li:li}
})

right.innerHTML += "<br>"+"max"

function maxCubeJ(d,lc,li,lv){
max=[]
for (var iv=0; iv<li*lv; iv++) {
	m=-1
	for (var c = 0; c < lc; c++) {
		civ = c + iv * lc
		// d1 = d[c][i][v] // d at x,y,z
		//(z * xMax * yMax) + (y * xMax) + x;
	
		d1 = cube[civ]
		if (d1 > m) {
			m = d1 //min
		}
	}
	right.innerHTML += "<br>"+m
	max.push(m)
}
return m
}
max = maxCubeJ(cube,lc,li,lv)



const doFnorm = gpu.createKernel(function(m,n) {
	var iv = this.thread.x
	var fnorm
	//fnorm =  (m[iv]-n[iv])
	fnorm = 1/ (m[iv]-n[iv])
	return fnorm
}, {
	dimensions: [li*lv*lc],
})
right.innerHTML += "<br>"+"fnorm"

function doFnormJ(min,max,lc,li,lv) {
fnormdone=[]
for (var iv=0; iv<li*lv; iv++) {
	fnorm = 1/ (max[iv]-min[iv])
	right.innerHTML += "<br>"+fnorm
	fnormdone.push(fnorm)
}
return fnormdone
}
fnorm = doFnormJ(min,max,lc,li,lv)


const doScores = gpu.createKernel(function(d,m,n,fnorm, minscore, maxscore) {
	var v,i,iv,civ,ci,normit,score
	civ = this.thread.x

	v = Math.floor(civ / (lc*li))
	ci = civ - v*lc*li
	i = Math.floor(ci / lc)
	iv = v * li + i

	//normit = (d[civ]-n[iv])*fnorm[iv] // indices must be wrong earlier
	normit = (d[civ]-n[iv]) / (m[iv]-n[iv])  
	score = Math.floor(.5+minscore+(maxscore-minscore)*(1-normit))
	//return normit
	return score
}, {
	dimensions: [lc*li*lv],
	constants: {lv:lv,lc:lc,li:li}
})

right.innerHTML += "<br>"+"scores"
maxscore=5
minscore=0

function doScoresJ(cube,max,min,fnorm,lc,li,lv) {
scores=[]
for (var civ=0; civ<lc*li*lv; civ++) {
	v = Math.floor(civ / (lc*li))
	ci = civ - v*lc*li
	i = Math.floor(ci / lc)
	iv = v * li + i

	//normit = (d[civ]-n[iv])*fnorm[iv] // indices must be wrong earlier
	normit = (cube[civ]-min[iv]) / (max[iv]-min[iv])  
	score = Math.floor(.5+minscore+(maxscore-minscore)*(1-normit))

	scores.push(score)
	right.innerHTML += "<br>"+score
}
return scores
}
scores = doScoresJ(cube,max,min,fnorm,lc,li,lv)

const doTally = gpu.createKernel(function(scores) {
	var ci,sum
	ci = this.thread.x
	sum = 0
	for (var v = 0; v < lv; v++) {
		//var civ = ci + v *lc*li
		//civ = c + i *lc + v *lc*li
		//sum += scores[civ]
		sum += scores[ci + v *lc*li]
	}
	return sum
}, {
	dimensions: [li*lc*lv], // weird that we need this extra lv dimension, which we remove later
	constants: {lv:lv,lc:lc,li:li}
})
right.innerHTML += "<br>"+"tally"

function doTallyJ(scores,lc,li,lv){
tally = []
for (var ci = 0; ci< lc*li; ci++) {
	
	sum = 0
	for (var v = 0; v < lv; v++) {
		civ = ci + v *lc*li
		//civ = c + i *lc + v *lc*li
		sum += scores[civ]
	}
	tally.push(sum)
	right.innerHTML += "<br>"+sum
}
return tally
}
tally = doTallyJ(scores,lc,li,lv)

const findWinner = gpu.createKernel(function(tally) {
	var i,ci,m,t1,mi
	i = this.thread.x
	m = -1
	mi = -1
	for (var c = 0; c < lc; c++) {
		ci = c + i * lc
		t1 = tally[ci]
		if(t1 > m) {
			m = t1
			mi = c
		}
	}
	return mi
}, {
	dimensions: [li*lv*lc],
	constants: {lv:lv,lc:lc,li:li}
})
right.innerHTML += "<br>"+"winner"
function findWinnerJ(tally,lc,li,lv){
miset=[]
for (var i = 0; i < li; i++) {
	m = -1
	mi = -1
	for (var c = 0; c < lc; c++) {
		ci = c + i * lc
		t1 = tally[ci]
		if(t1 > m) {
			m = t1
			mi = c
		}
	}
	right.innerHTML += "<br>"+mi
	miset.push(mi)
}
return miset
}
miset = findWinnerJ(tally,lc,li,lv)

if (!onlylast) {
const superKernel = gpu.combineKernels(d,minCube,maxCube,doFnorm,doScores,doTally,findWinner, function(xv,yv,xf,yf) {
		//var cube,min,max,fnorm,scores,tally,winner
		cube1 = d(xv, yv, xf, yf)
		min1 = minCube(cube1)
		max1 = maxCube(cube1)
		fnorm1 = doFnorm(max1,min1)
		scores1 = doScores(cube1,max1,min1,fnorm1,5,0)
		
		tally1 = doTally(scores1)
		winner1 = findWinner(tally1)
		return winner1
	})
var winner = superKernel(xv,yv,xf,yf).slice(0,li);
left.innerHTML += "<br>"+"megawinner"
left.innerHTML += "<br>"+winner.join("<br>")
right.innerHTML += "<br>"+"winner again"
right.innerHTML += "<br>"+miset.join("<br>")
}
// for ( var j=0;j<100;j++) {
// 	var winner = superKernel(xv,yv,xf,yf);
// 	left.innerHTML += "<br>"+winner[0])
// }

if(!onlylast){
cube2 = d(xv, yv, xf, yf)
const superKernel2 = gpu.combineKernels(minCube,maxCube,doFnorm,doScores,doTally,findWinner, function(cube2) {
		return findWinner(doTally(doScores(cube2,maxCube(cube2),minCube(cube2),doFnorm(maxCube(cube2),minCube(cube2)),5,0)))
	})
var winner2 = superKernel2(cube2).slice(0,li);
left.innerHTML += "<br>"+"megawinner2"
left.innerHTML += "<br>"+winner2.join("<br>")
right.innerHTML += "<br>"+"winner again"
right.innerHTML += "<br>"+miset.join("<br>")
}
// third try

function cubeToWinner(xv,yv,xf,yf) {
cube3 = d(xv, yv, xf, yf)
min3 = minCube(cube3)
max3 = maxCube(cube3)
fnorm3 = doFnorm(max3,min3)
scores3 = doScores(cube3,max3,min3,fnorm3,5,0)

tally3 = doTally(scores3)
winner3 = findWinner(tally3).slice(0,li);
return winner3
}
winner3 = cubeToWinner(xv,yv,xf,yf)


function cubeToWinnerJ(xv,yv,xf,yf,lc,li,lv) {
cube3 = dJ(xv, yv, xf, yf,lc,li,lv)
min3 = minCubeJ(cube3,lc,li,lv)
max3 = maxCubeJ(cube3,lc,li,lv)
fnorm3 = doFnormJ(max3,min3,lc,li,lv)
scores3 = doScoresJ(cube3,max3,min3,fnorm3,5,0,lc,li,lv)

tally3 = doTallyJ(scores3,lc,li,lv)
winner3 = findWinnerJ(tally3,lc,li,lv)
return winner3
}
winner4 = cubeToWinner(xv,yv,xf,yf)



left.innerHTML += "<br>"+"lessmegawinner3"
left.innerHTML += "<br>"+winner3.join("<br>")
right.innerHTML += "<br>"+"winner again"
right.innerHTML += "<br>"+miset.join("<br>")
right.innerHTML += "<br>"+"winner megaJ"
right.innerHTML += "<br>"+winner4.join("<br>")



left.innerHTML += "<br>"+"done"
right.innerHTML += "<br>"+"done"

	
</script>
